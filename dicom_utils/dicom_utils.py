# AUTOGENERATED! DO NOT EDIT! File to edit: Dicom Prep.ipynb (unless otherwise specified).

__all__ = ['get_fns', 'cut_outliers', 'cut_m', 'cut_frame', 'fix_monochrome', 'normalize', 'my_freqhist_bins',
           'my_hist_scaled', 'process_dcm', 'show_hist', 'compare_hists', 'compare_raws', 'show_raw']

# Cell
from fastai.basics import *
from fastai.medical.imaging import *

from pydicom.pixel_data_handlers import apply_voi_lut

# Cell
import warnings
warnings.filterwarnings("ignore", category = DeprecationWarning)

# Cell
def get_fns(df, stage = 'train'):
    if stage == 'train':
        lookup = train_lookup
    else:
        lookup = test_lookup
    return lookup[lookup.SOPInstanceUID.isin(df['SOPInstanceUID'].values)]['fn'].values

# Cell
def cut_outliers(arr):
    ### find a better name for this func...
    bins = np.histogram(arr.flatten(), bins = 100)
    bins_pct = bins[0] / bins[0].sum()
    bins_csum = bins_pct.cumsum()

    mid_idx = (bins_csum > 0.5).argmax()
    right_of_mid = bins_pct[mid_idx:]
    left_of_mid = bins_pct[:mid_idx]

    ## cut top
    if mid_idx < len(bins_pct):
        cut_sub = (right_of_mid <= 1e-9).argmax()
        if cut_sub == 0:
            return arr
        cut_idx = cut_sub + mid_idx ## The first bin, that contains very little values
        cut_value = bins[1][cut_idx] ## The upper bound of the last bin, that contained enough values
        arr[arr > cut_value] = cut_value

    ## cut bottom
    if mid_idx > 0:
        cut_sub = np.flip(left_of_mid <= 1e-9).argmax()
        if cut_sub == 0:
            return arr
        cut_idx = len(left_of_mid) - cut_sub
        cut_value = bins[1][cut_idx]
        arr[arr < cut_value] = cut_value

    return arr

# Cell
def cut_m(arr, mode = 'min'):
    from scipy.ndimage import gaussian_filter
    arr_blurr = gaussian_filter(arr, sigma = 30)
    mean_x, mean_y = arr_blurr.mean(axis = 0), arr_blurr.mean(axis = 1)
    rows, cols = arr.shape
    ε = 0.1 * arr.max()
    if mode == 'max':
        op = le
        thresh = arr_blurr.max() - ε
    else:
        op = ge
        thresh = arr_blurr.min() + ε

    x_lo = op(mean_x, thresh).argmax()
    x_hi = cols - np.flip(op(mean_x, thresh)).argmax()
    y_lo = op(mean_y, thresh).argmax()
    y_hi = rows - np.flip(op(mean_y, thresh)).argmax()

    tl = np.array([x_lo, y_lo])
    br = (x_hi, y_hi)

    return arr[y_lo:y_hi, x_lo:x_hi], tl, br

# Cell
def cut_frame(arr):
    arr, tl_1, br_1 = cut_m(arr, 'min')
    arr, tl_2, br_2 = cut_m(arr, 'max')
    return arr, tuple(tl_1 + tl_2), br_2

# Cell
def fix_monochrome(arr):
    return arr.max() - arr

# Cell
def normalize(arr):
    return (arr - arr.min())/ arr.max()

# Cell
def my_freqhist_bins(arr, trs = [0.,0.2,0.4,0.5,0.6,0.7,0.8,1.1], n_bins = 100):
    sub_arrs = []
    for i in range(len(trs)-1):
        #print(f'{trs[i]} to {trs[i+1]}:')
        lower_bound = arr >= trs[i]
        upper_bound = arr < trs[i+1]
        #print('sorting...')
        sliced_arr = arr[lower_bound & upper_bound]
        sliced_arr.sort()
        sub_arrs.append(sliced_arr)
        #print('done!')
    sorted_arr = np.concatenate(sub_arrs)
    assert(len(sorted_arr) == len(arr))

    t = np.concatenate(
        [np.array([0.001]),
         np.arange(n_bins)/n_bins+(1/2/n_bins),
         np.array([0.999])
        ])
    idxs = (t * len(sorted_arr)).astype(np.long)
    return np.unique(sorted_arr[idxs])

# Cell
def my_hist_scaled(self, brks):
    ys = np.linspace(0., 1., len(brks))
    x = np.interp(self.flatten(), brks, ys)
    return x.reshape(self.shape)

# Cell
def process_dcm(dcm, process = True, bins = None):
    arr = apply_voi_lut(dcm.pixel_array, dcm)
    if process == False:
        return arr, None, None
    if dcm.PhotometricInterpretation == "MONOCHROME1":
        arr = fix_monochrome(arr)
    ##arr, tl, br = cut_frame(arr)
    arr = cut_outliers(arr)
    arr = normalize(arr)
    #arr = my_hist_scaled(arr, bins)

    #return (arr, tl, br)
    return arr

# Cell
def show_hist(s, process = True):
    fns = get_fns(s)

    m = 1 if len(s) <= 3 else 4
    n = 1 if len(s) == 1 else 3
    fig, axs = plt.subplots(m,n, figsize = (20,15))
    if n == 1:
        dcm = fns[0].dcmread()
        arr, tl, br = process_dcm(dcm, process = process, bins = bins)
        axs.hist(arr.flatten())
    else:
        axs = axs.flatten()

        for i,ax in enumerate(axs):
            dcm = fns[i].dcmread()
            arr, tl, br = process_dcm(dcm, process = process, bins = bins)
            ax.hist(arr.flatten())

# Cell
def compare_hists(s):
    fns = get_fns(s)

    fig, axs = plt.subplots(len(fns), 2, figsize = (15,30))

    for i,fn in enumerate(fns):
        dcm = fn.dcmread()
        arr = dcm.pixel_array
        axs[i, 0].hist(arr.flatten())

        arr, tl, br = process_dcm(dcm, bins = bins)
        axs[i, 1].hist(arr.flatten())

# Cell
def compare_raws(s):
    fns = get_fns(s)

    fig, axs = plt.subplots(len(fns), 2, figsize = (10,50))

    for i,fn in enumerate(fns):
        dcm = fn.dcmread()
        arr = dcm.pixel_array
        axs[i, 0].imshow(arr, cmap = plt.cm.bone)

        arr, tl, br = process_dcm(dcm, bins = bins)
        axs[i, 1].imshow(arr, cmap = plt.cm.bone)

# Cell
def show_raw(s, process = True):
    fns = get_fns(s)

    m = 1 if len(s) <= 3 else 4
    n = 1 if len(s) == 1 else 3
    fig, axs = plt.subplots(m,n, figsize = (20,15))
    if n == 1:
        dcm = fns[0].dcmread()
        arr, tl, br = process_dcm(dcm, process = process, bins = bins)
        axs.imshow(arr, cmap = plt.cm.bone)
        axs.axis('off')
    else:
        axs = axs.flatten()

        for i,ax in enumerate(axs):
            dcm = fns[i].dcmread()
            arr, tl, br = process_dcm(dcm, process = process, bins = bins)
            ax.imshow(arr, cmap = plt.cm.bone)
            ax.axis('off')