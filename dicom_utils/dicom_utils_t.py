# AUTOGENERATED! DO NOT EDIT! File to edit: Dicom Prep tensor.ipynb (unless otherwise specified).

__all__ = ['get_fns', 'cut_outliers', 'cut_m', 'cut_frame', 'fix_monochrome', 'normalize', 'my_freqhist_bins',
           'my_hist_scaled', 'process_dcm', 'save_png', 'resize_img', 'init_df_cols', 'save_meta', 'process_arr',
           'show_hist', 'compare_hists', 'compare_raws', 'show_raw']

# Cell
from fastai.basics import *
from fastai.medical.imaging import *

from scipy.ndimage import gaussian_filter

# Cell
import warnings
warnings.filterwarnings("ignore", category = DeprecationWarning)

# Cell
def get_fns(df, stage = 'train'):
    if stage == 'train':
        lookup = train_lookup
    else:
        lookup = test_lookup
    return lookup[lookup.SOPInstanceUID.isin(df['SOPInstanceUID'].values)]['fn'].values

# Cell
def cut_outliers(arr):
    ### find a better name for this func...
    arr = tensor(arr)
    bins = torch.histc(arr.flatten(), bins = 100)
    bins_pct = bins / bins.sum()
    bins_csum = bins_pct.cumsum(dim = 0)

    mid_idx = torch.argmax((bins_csum > 0.5).type(torch.uint8))
    right_of_mid = bins_pct[mid_idx:]
    left_of_mid = bins_pct[:mid_idx]

    ## cut top
    cut_sub = (right_of_mid <= 1e-9).type(torch.uint8).argmax()
    if cut_sub == 0:
        return arr
    cut_idx = cut_sub + mid_idx ## The first bin, that contains very little values
    cut_value = bins[1][cut_idx] ## The upper bound of the last bin, that contained enough values
    arr[arr > cut_value] = cut_value

    ## cut bottom
    cut_sub = np.flip(left_of_mid <= 1e-9).type(torch.uint8).argmax()
    if cut_sub == 0:
        return arr
    cut_idx = len(left_of_mid) - cut_sub
    cut_value = bins[1][cut_idx]
    arr[arr < cut_value] = cut_value

    return arr

# Cell
def cut_m(arr, mode = 'min'):
    from fastai.medical.imaging import gauss_blur2d
    s = 0.3 * arr.shape[-1]
    arr_blurr = gauss_blur2d(arr, s) # make shure the arr is on the gpu
    mean_x, mean_y = arr_blurr.mean(axis = 0), arr_blurr.mean(axis = 1)
    rows, cols = arr.shape
    ε = 0.1 * arr.max()
    if mode == 'max':
        op = le
        thresh = arr_blurr.max() - ε
    else:
        op = ge
        thresh = arr_blurr.min() + ε

    x_lo = op(mean_x, thresh).type(torch.uint8).argmax()
    x_hi = cols - torch.flip(op(mean_x, thresh).type(torch.uint8), [-1]).argmax()
    y_lo = op(mean_y, thresh).type(torch.uint8).argmax()
    y_hi = rows - torch.flip(op(mean_y, thresh).type(torch.uint8), [-1]).argmax()

    tl = (x_lo.to(device='cpu'), y_lo.to(device='cpu'))
    br = (x_hi.to(device='cpu'), y_hi.to(device='cpu'))

    return arr[y_lo:y_hi, x_lo:x_hi], tl, br

# Cell
def cut_frame(arr):
    arr, tl_1, br_1 = cut_m_f(arr, 'min')
    arr, tl_2, br_2 = cut_m_f(arr, 'max')
    return arr, tl_1 + tl_2, br_2

# Cell
def fix_monochrome(arr):
    return arr.max() - arr

# Cell
def normalize(arr):
    return (arr - arr.min())/ arr.max()

# Cell
def my_freqhist_bins(arr, trs = [0.,0.2,0.4,0.5,0.6,0.7,0.8,1.1], n_bins = 100):
    # arr expected to be in between 0 & 1
    sub_arrs = []
    for i in range(len(trs)-1):
        #print(f'{trs[i]} to {trs[i+1]}:')
        lower_bound = arr >= trs[i]
        upper_bound = arr < trs[i+1]
        #print('sorting...')
        sliced_arr = arr[lower_bound & upper_bound]
        sub_arrs.append(sliced_arr.sort().values)
        #print('done!')
    sorted_arr = torch.cat(sub_arrs, 0)
    assert(len(sorted_arr) == len(arr))

    t = torch.cat([tensor([0.001]),
                   torch.arange(n_bins).float()/n_bins+(1/2/n_bins),
                   tensor([0.999])]
                 )
    idxs = (t * len(sorted_arr)).long()
    return sorted_arr[idxs].unique()

# Cell
def my_hist_scaled(self, brks):
    ys = np.linspace(0., 1., len(brks))
    x = np.interp(self.flatten(), brks, ys)
    return x.reshape(self.shape)

# Cell
def process_dcm(dcm, process = True, bins = None):
    arr = dcm.pixel_array
    if process == False:
        return arr, None, None
    if dcm.PhotometricInterpretation == "MONOCHROME1":
        arr = fix_monochrome(arr)
    arr, tl, br = cut_frame(arr)
    arr = cut_outliers(arr)
    arr = normalize(arr)
    #if bins.any() != None:
    #    return my_hist_scaled(arr, bins),tl,br
    return (arr, tl, br)

# Cell
def save_png(img, fn):
    fn = 'my_png' / Path(*fn.parts[-4:]).with_suffix('.png')
    fn.parent.mkdir(parents = True, exist_ok = True)
    img.save(fn, quality = 90)

# Cell
def resize_img(arr, new_width = 512):
    img = Image.fromarray((arr * 255).byte().numpy(), mode = 'L')
    scalar = new_width / img.size[0]
    resized_img = img.resize((new_width, int(img.size[1] * scalar)), resample = Image.LANCZOS)
    return resized_arr

# Cell
def init_df_cols(df):
    zs = np.zeros(df.shape[0], dtype = 'object')
    df['top_left'] = zs
    df['bottom_right'] = zs
    df['cut_size'] = zs
    df['new_size'] = zs

def save_meta(arr, fn, tl, br, df, new_size):
    init_df_cols(df)
    idx = df[df.id == fn.stem].index.item()

    img = Image.fromarray((arr * 255).astype(np.uint8))
    scalar = new_width / img.size[0]
    resized_img = img.resize((new_width, int(img.size[1] * scalar)), resample = Image.LANCZOS)

    df.at[idx, 'top_left'] = tl
    df.at[idx, 'bottom_right'] = br
    df.at[idx, 'cut_size'] = arr.shape[1], arr.shape[0]
    df.at[idx, 'new_size'] = new_size

# Cell
def process_arr(arr, process = True, bins = None):
    from fastai.medical.imaging import hist_scaled
    arr = to_device(arr)
    arr, tl, br = cut_frame(arr)
    arr = cut_outliers_t(arr)
    arr = normalize(arr)
    arr = arr.hist_scaled(tensor(bins))
    return (arr, tl, br)

# Cell
def show_hist(s, process = True):
    fns = get_fns(s)

    m = 1 if len(s) <= 3 else 4
    n = 1 if len(s) == 1 else 3
    fig, axs = plt.subplots(m,n, figsize = (20,15))
    if n == 1:
        dcm = fns[0].dcmread()
        arr, tl, br = process_dcm(dcm, process = process, bins = bins)
        axs.hist(arr.flatten())
    else:
        axs = axs.flatten()

        for i,ax in enumerate(axs):
            dcm = fns[i].dcmread()
            arr, tl, br = process_dcm(dcm, process = process, bins = bins)
            ax.hist(arr.flatten())

# Cell
def compare_hists(s):
    fns = get_fns(s)

    fig, axs = plt.subplots(len(fns), 2, figsize = (15,30))

    for i,fn in enumerate(fns):
        dcm = fn.dcmread()
        arr = dcm.pixel_array
        axs[i, 0].hist(arr.flatten())

        arr, tl, br = process_dcm(dcm, bins = bins)
        axs[i, 1].hist(arr.flatten())

# Cell
def compare_raws(s):
    fns = get_fns(s)

    fig, axs = plt.subplots(len(fns), 2, figsize = (10,50))

    for i,fn in enumerate(fns):
        dcm = fn.dcmread()
        arr = dcm.pixel_array
        axs[i, 0].imshow(arr, cmap = plt.cm.bone)

        arr, tl, br = process_dcm(dcm, bins = bins)
        axs[i, 1].imshow(arr, cmap = plt.cm.bone)

# Cell
def show_raw(s, process = True):
    fns = get_fns(s)

    m = 1 if len(s) <= 3 else 4
    n = 1 if len(s) == 1 else 3
    fig, axs = plt.subplots(m,n, figsize = (20,15))
    if n == 1:
        dcm = fns[0].dcmread()
        arr, tl, br = process_dcm(dcm, process = process, bins = bins)
        axs.imshow(arr, cmap = plt.cm.bone)
        axs.axis('off')
    else:
        axs = axs.flatten()

        for i,ax in enumerate(axs):
            dcm = fns[i].dcmread()
            arr, tl, br = process_dcm(dcm, process = process, bins = bins)
            ax.imshow(arr, cmap = plt.cm.bone)
            ax.axis('off')